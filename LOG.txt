

7/6
・Dynamic Web Projectで新規作成
・リポジトリ作成
・TODOを出した。在庫管理のお題でいけるかどうか、いろいろ疑問がある。MLで相談すべきかな。
・リポジトリ作成 → TODO作成 → (Eclipseの)Project作成が正しい順序な気がする。
・モデルケースのところはこんなノリだとどうだろう？アジャイルサムライに似てる？ → 「これからTDDで在庫管理のためのプログラムを書いていこうと思う。あなたは在庫管理の問題について詳しいだろうか？僕はまったく詳しくないんだ。だから、いきなりプログラムを書いたりせず、まずはこの問題についてよく勉強して先生に教わって事例を調査して…という贅沢ができればいいんだけど、ごくシンプルに、時間がない。走りながら、プログラムを動かしながら、問題について学ばなければならない。
 「幸いなことに、まさにそんな状況にハマった人を助けるために、TDDという強力なツールがあるんだ。無知を恐れずに(それとやり直しや失敗や手戻りも恐れずに)、『僕には学ぶことができる。学んだことをコードに反映することもできる』と自信をもって、ジャングルを切り開くブッシュナイフのようにTDDを振り回しながら進んでいこう。うっかり自分の指をちょん切ったりしないように気をつけよう。
 「【言い訳セクション】先に言っておくけれど、あなたが *本当に* 在庫管理のプログラムを作らなければいけなくて、それなのに *本当に* 学ぶ時間がないとしたら、荷物をまとめて逃げ出す準備をしたほうがいい。僕ならそうする。在庫管理のような歴史のある、本当の意味で複雑で、たくさんの人が(何十年も！)取り組んできた問題について前提知識なしでいきなりプログラムを書こうという態度は、控えめに言って清水の舞台から裸で飛び降りるようなものだ。問題領域の基礎知識は勉強しよう。典型的な設計例を研究しよう。ベテランから話を聞こう。プロトタイプを書いたっていい。そこまでやって、もう知るべきことは全部わかったと思えるようになったら、TDDでプログラムを書き始めればいい。それでも未知の部分、走って初めてわかる情報、動作するプログラムから得られる知識がある。走りながら学ぶことはいつでもあるのだ。だからTDDが活かせるんだ。本書でTDDのモデルケースとして在庫管理を選んでいるのは、比較的わかりやすく(説明もしやすく)、比較的複雑で、簡単な設計から段階を踏んで進化していく例を見せられるためである。それ以上の意図はなく、在庫管理のような基本的(超基本的！)で難しい(たいへん難しい)問題をゼロからTDDで開発すべきだという主張もしていない。現実的に考えよう。現実的に考えるための材料をこのモデルケースから学んでもらえたら幸いだ。【言い訳終わり】
 さて、いったいなにをすればいいんだろうか？在庫管理っていうくらいだから、在庫がいくつあるか知りたいよね。Javaのコードとしては、こんなことができたらいい。
 
   int stock = item.getStock();

 itemは商品だ。たぶんItemクラスのオブジェクトなんだろう。在庫数はintになるような気がする。ポテトチップの在庫が0.35個とか10と2/3個なんてことはないから、整数でいいんじゃないか。
 こういうイメージを、TDDではテストケースに書いていく。上に挙げた1行だけを記述するために、JavaとJUnitではこれだけのコードが必要になる。Eclipseを使えばほとんど自動生成できるので、見た目ほどの手間ではない。
 
 ... 」

7/7
・在庫数のことをテスト書きながら実装
・例外のテストは@Test(expected=...)で書いたが、こないだ他の方法もあったよなあ。
・在庫の増減と再設定ができたところで、テストを見直して境界値と同値クラスを意識するよう値を入れ直す。
・intのMAX_VALUEとMIN_VALUEを使うのは単体テストとしてはやりすぎに感じる(コストに対するメリットが小さい)が、ブラックボックステストの考え方を示すために入れている。
・境界前後の値に変えたテストもあるが、「てきとうな」値のままのテストもある。適当な値は、テストを読んで「自然に」仕様が理解できるようにするため。
・ItemManagerは面倒だから一気に書いてコミットしちゃう
・「履歴が取れる」ではなく「指定時点の在庫を取得できる」が正しい要求だった。まずテストを書いて、ここからが大変だぞうというところ。ビッグリファクタリング。目の前の一歩ずつをきっちり踏んでいくと気づけば遠くまで来てしまうのである。テストだっていっぱい後から追加することになるのである。
・まずはList<Object[]>で履歴を保持できるようにして、動くようにした。これはFake Itか？ただの汚い本実装か？いずれにせよこっからリファクタリングする。
・この時点でsetStock()のテストが落ちている。this.stockを変えるのをやめてaddStock()で数字を調整するようにする。ところがこんどは、マイナスになるときに例外が起きなくなってしまう。
・addStock()で再びマイナスチェックをするようにして対応。すると残ったエラーは、setStock()で変化がなかったときの場合。これは例外が出ると困る。うまいこと直した。addStockInternal()という名前は仮のものでリファクタリング終わるまでに直す。
・addStockInternal()はaddEntry()となり、在庫数の操作はEntryを追加することという設計になった。リファクタリングはいったん終わり。
・リファクタリングができたのでテストを書く。同時に増減が起きると、計算の順番でマイナスになってしまう場合がある。ここで、本当に在庫数マイナスは不可なのか？という疑問が湧く。（ここまでは、特に確認せず当然マイナスになるわけないよねと思っているわけだ）
・ちゃんと考えてみれば、在庫管理というのは現実に存在するモノの状態を情報化して扱うものなのだから、現実と情報に誤差があったら正しいのは現実。現実に基づいて出した指示がプログラムに入力できないのは困るので、こういう制限は外さないといけない。仕様理解が不十分だったところを、テスト書いていたおかげで気づけたわけです。

7/8
・LOG.txtを上から下へ読むように変えた。
・関係ないけど@Test(timeout)を学んだ。

7/15
・在庫マイナス問題を実装に反映する。テストを直してから。テストケースに-1、MIN_VALUEがあるので、ケースの追加は不要そう。
・履歴取得だがなんに使うのかよくわからない。とりあえずList<Entry>をそのまま渡すようにしちゃえばいいんじゃね？
・ということでシンプルにテストして実装した。ここは後で変わりそう。
・RESTfulサービス化の準備をする。必要なjarを追加して、web.xmlを書き換える。
・web.xmlは素直な書き方ではなく、静的コンテンツやjspなどを使えるように。参照: http://blog.cles.jp/item/4702
・商品一覧を取得するREST APIをまず実装。テストはまだないので、ブラウザから動作確認する。最初はデータがないので0件のレスポンスとなる。
・データを作成するAPIの予定はまだないので、仮でテストデータを最初から作っておくようにした。ItemResourceのstaticブロックなので他のテストには影響ないが、早々にマシな方法を構築する必要がある。
・問題の半分は、XMLなりJSONなりをPOST/PUTする簡単なツールがないこと。ツールを導入してもいいが、テストドライバーとして開発することにする。ここで作ったものはすぐに、テストの自動化に流用できる。原稿では補足として、使えるツールを探すのも正しいアプローチだと解説する。
・まずはAPIで新規登録のクチを作った。これはこれで単体のテストを書いておく。
・このへんの戦略はこういうイメージ。まずはAPIを動くようにしてブラウザで確認→書いたAPIは単体のテストを書く→部品に使ってAPIを外部から叩くテストでゴールデンパスシナリオテストにする

7/17
・APIの単体テストを書いている。
・allItemsはルートがitems要素じゃないといけないことに気づいてガッカリ。まあいいや直そう。
・allItemsの複数件のテストのために、あちこちリファクタリングしたり実装を追加したりした。Item.equals()、XMLのパース。テストが汚くなったところ。

7/21
・順序が固定ならXMLのパースはいらなくなる。テストしやすいよう仕様を変えることにした。
・
7/23
・単体テストの部品をつかってAPIをHTTPで叩くテストを作る。
・まずはテストケースの中でXML生成するところをリファクタリングで整理した。
「元のテストケースをリファクタリングしていったら、商品のXMLを生成する便利なロジックができてしまったな。
すばらしい！こんな人生の絶頂では時折、悪魔のささやきが聞こえることがある。
このコード、もうテストと関係ないし、便利だからプロダクトコードとして使ってしまえばいのではないか。
なんという閃き！なんという節約！なんという一挙両得！
待て、心を落ち着けるんだ。悪魔のささやきに耳を貸して本当にいいのかい？
まあ、ほんとうにいいこともあるんだろうが、今はやめておいた方がいいだろう。理由は2つだ。
1.いくらうまく書けたと言ったところで、テストコードはテストコードだ。このコードをカバーするテストはない。
テストがないと言うことは品質は保証できない。品質を保証できないコードをプロダクトコードとするのはまさに悪魔の所行だ。
もちろんテストを書くことはできるのだが、そうすると次の理由とも相まって、それほどすばらしいアイデアには思えなくなってくるのだ。
2.このコードはテストで使っているものだが、プロダクトコードからも使うことになると、変更が避けられなくなる。
便利なコードなのであれば、プロダクトコードとして取り込んだ後で、さらなる変更、機能追加がされるはずだ。
(今回の例で言えば、商品のXMLにnameしかないというのは明らかに機能不足で、すぐに他の項目も追加する必要がある。)
そうしてプロダクトコードとして立派に育っていく機能が、テストでも使いやすいままであるとは限らない。
逆にテストでしか使わない機能を無闇とプロダクトコードに加えていくのもあまり感心できない(必要なこともままあるがな)。
たとえば、テストではわざと壊れたXMLを生成する機能があると便利かもしれないが、そんな機能がプロダクトコードに紛れ込むのは危険じゃないか？
生まれが同じでも、プロダクトコードとテストコードは所詮違う環境で違うように育っていくものなのだ。
また上記の理由に加えて、レスポンスのXMLを生成するロジックと同じものを使ってレスポンスが正しいXMLになっているか調べるというのは、なにをどうやってテストしているのかよくわからない状況になる。
正確には、現在のItemResourceTestは「期待するレスポンスが返ってくる」ことと「レスポンスは正しいXMLである」ことを一緒くたにテストしてしまっている。
そこを分離して、XML生成のロジックを厳密にテストしてやれば、レスポンスの内容を確認するときにはテストでXML生成部分を呼び出しても問題ではなくなる。
なので最後の理由は、あまり重要ではないだろうな。」

7/27
・APIのテストを書くために、テストシナリオをテストケースの形で書いた。まだまったく動かないが、どんなことをしたいのかの意図を、TODOをさらに細かくしたレベルで書いたものである。

7/29
・APIを叩くテストを書き始めた。最初は、商品がないこと。HttpUrlConnectionなどを使って実装する。
・商品を登録するAPIのところで、テストの初期化が必要なことに気づく。

8/3
・テストデータ(初期化)のクチを作った。