

7/6
・Dynamic Web Projectで新規作成
・リポジトリ作成
・TODOを出した。在庫管理のお題でいけるかどうか、いろいろ疑問がある。MLで相談すべきかな。
・リポジトリ作成 → TODO作成 → (Eclipseの)Project作成が正しい順序な気がする。
・モデルケースのところはこんなノリだとどうだろう？アジャイルサムライに似てる？ → 「これからTDDで在庫管理のためのプログラムを書いていこうと思う。あなたは在庫管理の問題について詳しいだろうか？僕はまったく詳しくないんだ。だから、いきなりプログラムを書いたりせず、まずはこの問題についてよく勉強して先生に教わって事例を調査して…という贅沢ができればいいんだけど、ごくシンプルに、時間がない。走りながら、プログラムを動かしながら、問題について学ばなければならない。
 「幸いなことに、まさにそんな状況にハマった人を助けるために、TDDという強力なツールがあるんだ。無知を恐れずに(それとやり直しや失敗や手戻りも恐れずに)、『僕には学ぶことができる。学んだことをコードに反映することもできる』と自信をもって、ジャングルを切り開くブッシュナイフのようにTDDを振り回しながら進んでいこう。うっかり自分の指をちょん切ったりしないように気をつけよう。
 「【言い訳セクション】先に言っておくけれど、あなたが *本当に* 在庫管理のプログラムを作らなければいけなくて、それなのに *本当に* 学ぶ時間がないとしたら、荷物をまとめて逃げ出す準備をしたほうがいい。僕ならそうする。在庫管理のような歴史のある、本当の意味で複雑で、たくさんの人が(何十年も！)取り組んできた問題について前提知識なしでいきなりプログラムを書こうという態度は、控えめに言って清水の舞台から裸で飛び降りるようなものだ。問題領域の基礎知識は勉強しよう。典型的な設計例を研究しよう。ベテランから話を聞こう。プロトタイプを書いたっていい。そこまでやって、もう知るべきことは全部わかったと思えるようになったら、TDDでプログラムを書き始めればいい。それでも未知の部分、走って初めてわかる情報、動作するプログラムから得られる知識がある。走りながら学ぶことはいつでもあるのだ。だからTDDが活かせるんだ。本書でTDDのモデルケースとして在庫管理を選んでいるのは、比較的わかりやすく(説明もしやすく)、比較的複雑で、簡単な設計から段階を踏んで進化していく例を見せられるためである。それ以上の意図はなく、在庫管理のような基本的(超基本的！)で難しい(たいへん難しい)問題をゼロからTDDで開発すべきだという主張もしていない。現実的に考えよう。現実的に考えるための材料をこのモデルケースから学んでもらえたら幸いだ。【言い訳終わり】
 さて、いったいなにをすればいいんだろうか？在庫管理っていうくらいだから、在庫がいくつあるか知りたいよね。Javaのコードとしては、こんなことができたらいい。
 
   int stock = item.getStock();

 itemは商品だ。たぶんItemクラスのオブジェクトなんだろう。在庫数はintになるような気がする。ポテトチップの在庫が0.35個とか10と2/3個なんてことはないから、整数でいいんじゃないか。
 こういうイメージを、TDDではテストケースに書いていく。上に挙げた1行だけを記述するために、JavaとJUnitではこれだけのコードが必要になる。Eclipseを使えばほとんど自動生成できるので、見た目ほどの手間ではない。
 
 ... 」

7/7
・在庫数のことをテスト書きながら実装
・例外のテストは@Test(expected=...)で書いたが、こないだ他の方法もあったよなあ。
・在庫の増減と再設定ができたところで、テストを見直して境界値と同値クラスを意識するよう値を入れ直す。
・intのMAX_VALUEとMIN_VALUEを使うのは単体テストとしてはやりすぎに感じる(コストに対するメリットが小さい)が、ブラックボックステストの考え方を示すために入れている。
・境界前後の値に変えたテストもあるが、「てきとうな」値のままのテストもある。適当な値は、テストを読んで「自然に」仕様が理解できるようにするため。
・ItemManagerは面倒だから一気に書いてコミットしちゃう
・「履歴が取れる」ではなく「指定時点の在庫を取得できる」が正しい要求だった。まずテストを書いて、ここからが大変だぞうというところ。ビッグリファクタリング。目の前の一歩ずつをきっちり踏んでいくと気づけば遠くまで来てしまうのである。テストだっていっぱい後から追加することになるのである。
・まずはList<Object[]>で履歴を保持できるようにして、動くようにした。これはFake Itか？ただの汚い本実装か？いずれにせよこっからリファクタリングする。
・この時点でsetStock()のテストが落ちている。this.stockを変えるのをやめてaddStock()で数字を調整するようにする。ところがこんどは、マイナスになるときに例外が起きなくなってしまう。
・addStock()で再びマイナスチェックをするようにして対応。すると残ったエラーは、setStock()で変化がなかったときの場合。これは例外が出ると困る。うまいこと直した。addStockInternal()という名前は仮のものでリファクタリング終わるまでに直す。
・addStockInternal()はaddEntry()となり、在庫数の操作はEntryを追加することという設計になった。リファクタリングはいったん終わり。
・リファクタリングができたのでテストを書く。同時に増減が起きると、計算の順番でマイナスになってしまう場合がある。ここで、本当に在庫数マイナスは不可なのか？という疑問が湧く。（ここまでは、特に確認せず当然マイナスになるわけないよねと思っているわけだ）
・ちゃんと考えてみれば、在庫管理というのは現実に存在するモノの状態を情報化して扱うものなのだから、現実と情報に誤差があったら正しいのは現実。現実に基づいて出した指示がプログラムに入力できないのは困るので、こういう制限は外さないといけない。仕様理解が不十分だったところを、テスト書いていたおかげで気づけたわけです。

7/8
・LOG.txtを上から下へ読むように変えた。
・関係ないけど@Test(timeout)を学んだ。

7/15
・在庫マイナス問題を実装に反映する。テストを直してから。